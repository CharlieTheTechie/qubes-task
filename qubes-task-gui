#!/usr/bin/python3
# qubes-task-gui.py

# TODO following imports somehow needed for execution already built pyinstaller exe
from __future__ import print_function
import xml.etree.ElementTree
import glob
import numbers
import ast
# TODO end of imports which are required by pyinstaller exe

import subprocess
import sys

import json
import shelve

from unman_repo_installaton import tasks_repo, templates_repo


# Following code ensure that pyinstaller exe use exact needed imports
def append_system_libs():
    # execute the "python3 -c 'import site; print(json.dumps(site.getsitepackages()))'" command and capture the output
    result = subprocess.run(["python3", "-c", "import site, json; print(json.dumps(site.getsitepackages()))"],
                            stdout=subprocess.PIPE)

    # extract the output from the result and parse it as JSON
    output = json.loads(result.stdout)
    # append each path to sys.path
    for path in output:
        sys.path.append(path)


def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    base_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
    return os.path.join(base_path, relative_path)


# let's use all libraries from the client to ensure maximum compatibility
append_system_libs()

from PyQt5 import QtWidgets, QtGui, uic
from PyQt5.QtWidgets import (
    QWidget, QApplication, QButtonGroup, QHBoxLayout, QVBoxLayout,
    QCheckBox, QLabel, QLineEdit, QMainWindow, QPushButton, QScrollArea,
    QSizePolicy, QSpacerItem, QTabWidget, QStackedLayout, QMessageBox)

from PyQt5.QtCore import QObject, Qt, pyqtSignal, QProcess, QTimer, QThread, QSize
from PyQt5.QtGui import QPainter, QFont, QColor, QPen, QPixmap
# from row import TaskRowWidget
from qubes_task import *
from qubesadmin.tools.qvm_template import Template as Task

from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QPushButton, QStyle

appl = qubesadmin.Qubes()
args = ['dict']
p_args, args = parser.parse_known_args(args)
p_args = parser.parse_args(args, p_args)
p_args.repo_files = REPO_FILE
p_args.updatevm = appl.updatevm


class TaskRowWidget(QWidget):

    def __init__(self, parent, name, summary):
        super(TaskRowWidget, self).__init__()
        self.parent = parent
        self.name = name  # Name of widget used for searching.
        self.summary = summary
        self.is_on = False

        self.setAccessibleName = name
        self.lbl2 = QLabel(self.summary)
        self.checked = QCheckBox(self.name)
        parent.taskGroup.addButton(self.checked)
        self.btn_details = QPushButton("Details")
        self.btn_details.setAccessibleName(name)
        self.btn_details.setCheckable(False)
        self.btn_details.clicked.connect(parent.details_clicked)

        self.hbox = QHBoxLayout()
        self.hbox.addWidget(self.checked, 20)
        self.hbox.addWidget(self.lbl2, 60)
        self.hbox.addWidget(self.btn_details)
        self.setLayout(self.hbox)


class Worker(QThread):
    finished = pyqtSignal(dict)

    def run(self):
        try:
            tsks = list_tasks(p_args, appl, 'dict')
        except  Exception as e:
            tsks = {"exception": str(e)}
        self.finished.emit(tsks)


class MainWindow(QMainWindow):
    fancy_directory = os.path.expanduser("~/.qubes-fancy-task")
    fancy_state_path = os.path.join(fancy_directory, 'state')

    def __init__(self, command='dict', *args, **kwargs):
        super().__init__()

        # create qubes-fancy-task directory
        os.makedirs(self.fancy_directory, exist_ok=True)

        # Tabs
        self.tabWidget = QTabWidget()
        self.tabOverview = QWidget()
        self.tabTasks = QWidget()
        self.tabTemplate = QWidget()

        # Add tabs to the tab widget
        self.tabWidget.addTab(self.tabOverview, "Overview")
        self.tabWidget.addTab(self.tabTasks, "Tasks")
        self.tabWidget.addTab(self.tabTemplate, "Templates")

        self.tabOverview.setLayout(self.render_overview_tab())
        self.tabTemplate.setLayout(self.render_template_tab())
        self.tabTasks.setLayout(self.render_tasks_tab())

        self.setCentralWidget(self.tabWidget)

        self.setGeometry(600, 100, 900, 600)
        self.setWindowTitle('Qubes Task Manager')
        self.setWindowIcon = QtGui.QIcon.fromTheme("qubes-manager")

    def checkbox_state_changed(self, state):
        if state == 0:
            self.set_update_on_start(False)
        elif state == 2:
            self.set_update_on_start(True)

    def render_tasks_tab(self):
        reponame = "tasks"

        self.taskContainerLayout = QStackedLayout()
        self.taskContainerLayout.addWidget(self.render_tasks())
        self.taskContainerLayout.addWidget(self.render_installation_tab(tasks_repo, self.taskContainerLayout, 2))
        self.taskContainerLayout.addWidget(self.refresh_widget())

        if tasks_repo.is_installed():
            self.taskContainerLayout.setCurrentIndex(2)
            if self.update_on_start():
                self.refresh_on_start_checkbox1.hide()
                self.refresh_tasks()
        else:
            self.taskContainerLayout.setCurrentIndex(1)
        return self.taskContainerLayout

    def render_overview_tab(self):
        # Tab overview
        v_layout_overview = QVBoxLayout()
        label = QLabel("Task manager")
        v_layout_overview.addWidget(label)

        return v_layout_overview

    def render_template_tab(self):

        taskContainerLayout = QStackedLayout()
        taskContainerLayout.addWidget(self.render_templates_tab())
        taskContainerLayout.addWidget(self.render_installation_tab(templates_repo, taskContainerLayout, 0))

        if templates_repo.is_installed():
            taskContainerLayout.setCurrentIndex(0)
        else:
            taskContainerLayout.setCurrentIndex(1)
        return taskContainerLayout

    def render_templates_tab(self):
        # Tab templates
        v_layout_templates = QVBoxLayout()

        # Load the image into QPixmap
        pixmap = QPixmap(resource_path("media/QVM-TEMPLATE-GUI.png"))
        template_instruction = QLabel()
        template_instruction.setPixmap(pixmap)

        # List all files in the directory
        directory = resource_path("media/templates")
        files = os.listdir(directory)
        installation_icons = QWidget()
        hIconLayout = QHBoxLayout()

        for file in files:
            # Check if the file is an image (you can add other formats if needed)
            if file.endswith(".png") or file.endswith(".jpg") or file.endswith(".jpeg"):
                # Create the full file path
                filepath = os.path.join(directory, file)

                # Load the image into QPixmap
                pixmap = QPixmap(filepath)

                # Scale pixmap
                pixmap = pixmap.scaled(45, 45)

                # Create a QLabel and set the QPixmap to it
                label = QLabel()
                label.setPixmap(pixmap)

                # Add label to the layout
                hIconLayout.addWidget(label)

        installation_icons.setLayout(hIconLayout)
        v_layout_templates.addWidget(installation_icons)

        label_qvm_template_gui = QLabel("Look for i3sec templates in repository column ")
        v_layout_templates.addWidget(label_qvm_template_gui)
        v_layout_templates.addWidget(template_instruction)

        btn_go_to_qvm_template_gui = QPushButton("Go to qvm-template-gui")
        btn_go_to_qvm_template_gui.setCheckable(False)
        btn_go_to_qvm_template_gui.clicked.connect(self.go_to_qvm_template_gui)
        v_layout_templates.addWidget(btn_go_to_qvm_template_gui)
        installStackWidget = QWidget()
        installStackWidget.setLayout(v_layout_templates)
        return installStackWidget

    def render_installation_tab(self, repo, stack, index):
        waring_widget = QWidget()
        warning_HLayout = QHBoxLayout()
        warning_icon = QApplication.style().standardIcon(QStyle.SP_MessageBoxWarning)
        warning_pixmap = warning_icon.pixmap(warning_icon.actualSize(QSize(64, 64)))
        warning_label_icon = QLabel(self)
        warning_label_icon.setPixmap(warning_pixmap)
        warning_HLayout.addWidget(warning_label_icon)
        warning_label = QLabel(f"The {repo.reponame} repository is not installed")
        warning_label.setAlignment(Qt.AlignLeft)
        warning_label_font = warning_label.font()  # get the current font
        warning_label_font.setPointSize(warning_label_font.pointSize() * 2)  # make font 4 times larger
        warning_label_font.setBold(True)  # make font bold
        warning_label.setFont(warning_label_font)
        warning_HLayout.addWidget(warning_label)

        instruction_label = QLabel(
            f"The official instruction from UNMAN about how to install the {repo.reponame} repository")

        instruction_description_scroll = QScrollArea()
        instruction_description_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        instruction_description_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        instruction_description_scroll.setWidgetResizable(True)
        instruction_description_scroll.setWidget(QLabel(repo.instructions))

        # Create QPushButton instances for OK and Cancel
        installation_button = QPushButton("OR you can set up it automatically (will run subcomands with \"sudo\")")
        font = installation_button.font()  # get the current font
        font.setBold(True)  # make font bold
        installation_button.setFont(font)  # set the modified font
        installation_button.setStyleSheet(
            'QPushButton {background-color: yellow; color: black;}')  # set the button to yellow

        def accept():
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Question)
            msgBox.setText("This action will run subcommands with \"sudo\".")
            msgBox.setWindowTitle("Confirmation")
            msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)

            returnValue = msgBox.exec()
            if returnValue == QMessageBox.Ok:
                repo.install()
                stack.setCurrentIndex(index)

        # Connect buttons to the appropriate slots (functions)
        installation_button.clicked.connect(accept)

        # Add the QLabel and QPushButtons to the layout
        installStackLayout = QVBoxLayout()

        waring_widget.setLayout(warning_HLayout)

        installStackLayout.addWidget(waring_widget)
        installStackLayout.addWidget(instruction_label)
        installStackLayout.addWidget(instruction_description_scroll, 40)
        installStackLayout.addWidget(installation_button)
        installStackWidget = QWidget()
        installStackWidget.setLayout(installStackLayout)
        return installStackWidget

    def render_tasks(self):
        # Tab tasks
        self.tasksLayout = QVBoxLayout()  # Tasks container layout.
        self.taskGroup = QButtonGroup()
        self.taskGroup.setExclusive(False)
        spacer = QSpacerItem(1, 1, QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.tasks = QWidget()
        self.tasksLayout.addItem(spacer)
        self.tasks.setLayout(self.tasksLayout)
        self.lbl = QLabel(""" Description
                            """)
        self.lbl.setAlignment(Qt.AlignTop)
        # Scroll Area Properties.
        self.scroll = QScrollArea()
        self.scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll.setWidgetResizable(True)
        self.scroll.setWidget(self.tasks)

        self.scroll2 = QScrollArea()
        self.scroll2.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.scroll2.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll2.setWidgetResizable(True)
        self.scroll2.setWidget(self.lbl)

        self.searchbar = QLineEdit()
        self.btn_install = QPushButton("Install")
        self.btn_install.setCheckable(False)
        self.btn_install.clicked.connect(self.install_tasks)

        self.refresh_on_start_checkbox2 = QCheckBox("Refresh tasks on start")
        self.refresh_on_start_checkbox2.setChecked(self.update_on_start())
        self.refresh_on_start_checkbox2.stateChanged.connect(
            self.checkbox_state_changed)  # Connect the signal to the slot

        taskStackLayout = QVBoxLayout()
        # containerLayout.addWidget(self.searchbar)
        taskStackLayout.addWidget(self.btn_install)
        taskStackLayout.addWidget(self.refresh_on_start_checkbox2)
        taskStackLayout.addWidget(self.scroll, 60)
        taskStackLayout.addWidget(self.scroll2, 40)
        taskStackWidget = QWidget()
        taskStackWidget.setLayout(taskStackLayout)
        return taskStackWidget

    def go_to_qvm_template_gui(self):
        subprocess.Popen(["qvm-template-gui"], start_new_session=True)

    def refresh_widget(self):
        # Tab tasks
        self.default_refresh_text = """ Update can take time in case of weak connection or if sys-whonix not started\n"""
        self.lbl = QLabel(self.default_refresh_text)
        self.lbl.setAlignment(Qt.AlignTop)
        self.lbl.hide()
        self.refresh_counter = 1

        self.refresh_on_start_checkbox1 = QCheckBox("Refresh tasks on start")
        self.refresh_on_start_checkbox1.setChecked(self.update_on_start())
        self.refresh_on_start_checkbox1.stateChanged.connect(
            self.checkbox_state_changed)  # Connect the signal to the slot

        self.btn_refresh = QPushButton("Pull tasks; can take time if sys-whonix not started")
        self.btn_refresh.setCheckable(False)
        self.btn_refresh.clicked.connect(self.refresh_tasks)

        refreshStackLayout = QVBoxLayout()
        refreshStackLayout.addWidget(self.btn_refresh)
        refreshStackLayout.addWidget(self.lbl)
        refreshStackLayout.addWidget(self.refresh_on_start_checkbox1)
        refreshStackWidget = QWidget()
        refreshStackWidget.setLayout(refreshStackLayout)
        return refreshStackWidget

    def finish_refresh(self, results):
        self.outputs = {}
        self.outputs = results
        if "exception" in self.outputs:
            QtWidgets.QMessageBox.warning(
                self,
                self.tr("EXCEPTION"),
                self.tr(f"Happened exception during tasks refresh {self.outputs['exception']}\n PLEASE TRY AGAIN"))
            self.btn_refresh.show()
            self.lbl.hide()
        else:
            self.widget_names = self.outputs.keys()
            for name in self.widget_names:
                detail = self.outputs[name]['summary']
                item = TaskRowWidget(self, name, detail)
                self.tasksLayout.addWidget(item)
            self.taskContainerLayout.setCurrentIndex(0)
        self.refresh_timer.stop()

    def refresh_tasks(self):
        self.btn_refresh.hide()
        self.lbl.show()
        self.refresh_timer = QTimer()
        self.refresh_timer.setInterval(1000)  # 1000 ms = 1 s
        self.refresh_timer.timeout.connect(self.update_label)
        self.refresh_timer.start()
        self.worker = Worker()
        self.worker.finished.connect(self.finish_refresh)
        self.worker.start()

    def update_label(self):
        self.refresh_counter += 1

        refresh_text = self.default_refresh_text
        refresh_text += f"\nit runs for {self.refresh_counter} sec \n"
        if self.refresh_counter > 8:  # i just choosed 8; no sense
            refresh_text += "\nrefresh taking longer then usual probably it inits sys-whonix\n"

        self.lbl.setText(refresh_text)

    def details_clicked(widget, state):
        sending_widget = widget.sender()
        name = (sending_widget.accessibleName())
        desc = widget.outputs[name]['description']
        w.lbl.setText(desc)

    def install_tasks(widget, state):
        update_cmd = "sudo qubes-dom0-update "
        prefix = "3isec-qubes-"
        checked_buttons = [i for i, button in enumerate(w.taskGroup.buttons()) if button.isChecked()]
        pkgs_to_install = []
        for i in checked_buttons:
            pkgs_to_install.append(prefix + w.taskGroup.buttons()[i].text())
        try:
            if len(pkgs_to_install) == 0:
                QtWidgets.QMessageBox.warning(
                    widget,
                    widget.tr("No selected tasks"),
                    widget.tr("No tasks were selected"))
                return
            install_list = " ".join(pkgs_to_install)
            child = subprocess.Popen(update_cmd + install_list, shell=True)
            output = child.communicate()[0]
        except Exception as e:  # pylint: disable=broad-except
            # output = child.communicate()[0]
            return 1
        return 0

    def update_on_start(self):
        with shelve.open(self.fancy_state_path) as db:
            if 'update_on_start' in db:
                return db['update_on_start']
            return False

    def set_update_on_start(self, value):
        print(value)
        with shelve.open(self.fancy_state_path) as db:
            db['update_on_start'] = bool(value)  # need stronger validation


app = QtWidgets.QApplication(sys.argv)
w = MainWindow()
w.show()
sys.exit(app.exec_())
