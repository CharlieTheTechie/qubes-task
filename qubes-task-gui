#!/usr/bin/python3
# qubes-task-gui.py

# TODO following imports somehow needed for execution already built pyinstaller exe
from __future__ import print_function
import xml.etree.ElementTree
import glob
import numbers
import ast
# TODO end of imports which are required by pyinstaller exe

import subprocess
import sys

import json
import shelve

from unman_repo_installaton import install_repo_3isec, install_repo_3isec_tmpl, is_inited_repo_3isec, \
    is_inited_repo_3isec_tmpl


# Following code ensure that pyinstaller exe use exact needed imports
def append_system_libs():
    # execute the "python3 -c 'import site; print(json.dumps(site.getsitepackages()))'" command and capture the output
    result = subprocess.run(["python3", "-c", "import site, json; print(json.dumps(site.getsitepackages()))"],
                            stdout=subprocess.PIPE)

    # extract the output from the result and parse it as JSON
    output = json.loads(result.stdout)
    # append each path to sys.path
    for path in output:
        sys.path.append(path)


def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    base_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
    return os.path.join(base_path, relative_path)


# let's use all libraries from the client to ensure maximum compatibility
append_system_libs()

from PyQt5 import QtWidgets, QtGui, uic
from PyQt5.QtWidgets import (
    QWidget, QApplication, QButtonGroup, QHBoxLayout, QVBoxLayout,
    QCheckBox, QLabel, QLineEdit, QMainWindow, QPushButton, QScrollArea,
    QSizePolicy, QSpacerItem, QTabWidget, QStackedLayout, QMessageBox)

from PyQt5.QtCore import QObject, Qt, pyqtSignal, QProcess, QTimer, QThread
from PyQt5.QtGui import QPainter, QFont, QColor, QPen, QPixmap
# from row import TaskRowWidget
from qubes_task import *
from qubesadmin.tools.qvm_template import Template as Task

appl = qubesadmin.Qubes()
args = ['dict']
p_args, args = parser.parse_known_args(args)
p_args = parser.parse_args(args, p_args)
p_args.repo_files = REPO_FILE
p_args.updatevm = appl.updatevm


class TaskRowWidget(QWidget):

    def __init__(self, parent, name, summary):
        super(TaskRowWidget, self).__init__()
        self.parent = parent
        self.name = name  # Name of widget used for searching.
        self.summary = summary
        self.is_on = False

        self.setAccessibleName = name
        self.lbl2 = QLabel(self.summary)
        self.checked = QCheckBox(self.name)
        parent.taskGroup.addButton(self.checked)
        self.btn_details = QPushButton("Details")
        self.btn_details.setAccessibleName(name)
        self.btn_details.setCheckable(False)
        self.btn_details.clicked.connect(parent.details_clicked)

        self.hbox = QHBoxLayout()
        self.hbox.addWidget(self.checked, 20)
        self.hbox.addWidget(self.lbl2, 60)
        self.hbox.addWidget(self.btn_details)
        self.setLayout(self.hbox)


class Worker(QThread):
    finished = pyqtSignal(dict)

    def run(self):
        try:
            tsks = list_tasks(p_args, appl, 'dict')
        except  Exception as e:
            tsks = {"exception": str(e)}
        self.finished.emit(tsks)


class MainWindow(QMainWindow):
    fancy_directory = os.path.expanduser("~/.qubes-fancy-task")
    fancy_state_path = os.path.join(fancy_directory, 'state')

    def __init__(self, command='dict', *args, **kwargs):
        super().__init__()

        # create qubes-fancy-task directory
        os.makedirs(self.fancy_directory, exist_ok=True)

        # Tabs
        self.tabWidget = QTabWidget()
        self.tabOverview = QWidget()
        self.tabTasks = QWidget()
        self.tabTemplate = QWidget()

        # Add tabs to the tab widget
        self.tabWidget.addTab(self.tabOverview, "Overview")
        self.tabWidget.addTab(self.tabTasks, "Tasks")
        self.tabWidget.addTab(self.tabTemplate, "Templates")

        self.tabOverview.setLayout(self.render_overview_tab())
        self.tabTemplate.setLayout(self.render_templates_tab())
        self.tabTasks.setLayout(self.render_tasks_tab())

        self.setCentralWidget(self.tabWidget)

        self.setGeometry(600, 100, 900, 600)
        self.setWindowTitle('Qubes Task Manager')
        self.setWindowIcon = QtGui.QIcon.fromTheme("qubes-manager")

    def checkbox_state_changed(self, state):
        if state == 0:
            self.set_update_on_start(False)
        elif state == 2:
            self.set_update_on_start(True)

    def render_tasks_tab(self):
        self.taskContainerLayout = QStackedLayout()
        self.taskContainerLayout.addWidget(self.render_tasks())
        self.taskContainerLayout.addWidget(self.render_repo_install())
        self.taskContainerLayout.addWidget(self.refresh_widget())

        if is_inited_repo_3isec():
            self.taskContainerLayout.setCurrentIndex(2)
            if self.update_on_start():
                self.refresh_on_start_checkbox1.hide()
                self.refresh_tasks()
        else:
            self.taskContainerLayout.setCurrentIndex(1)
        return self.taskContainerLayout

    def render_overview_tab(self):
        # Tab overview
        v_layout_overview = QVBoxLayout()
        label = QLabel("Task manager")
        v_layout_overview.addWidget(label)

        return v_layout_overview

    def render_templates_tab(self):
        # Tab templates
        v_layout_templates = QVBoxLayout()
        self.btn_template_inst = QPushButton("Set up templates i3sec")
        self.btn_template_inst.setCheckable(False)
        # self.btn_template_inst.setStyleSheet("""
        #     QPushButton {
        #         background-color: #4CAF50;
        #         color: white;
        #         border: none;
        #         padding: 15px 32px;
        #         text-align: center;
        #         text-decoration: none;
        #         display: inline-block;
        #         font-size: 16px;
        #         margin: 4px 2px;
        #         cursor: pointer;
        #         transition-duration: 0.4s;
        #     }
        #
        #     QPushButton:hover {
        #         background-color: #45a049;
        #     }
        # """)
        self.btn_template_inst.clicked.connect(self.install_templates)
        v_layout_templates.addWidget(self.btn_template_inst)

        # Load the image into QPixmap
        pixmap = QPixmap(resource_path("media/QVM-TEMPLATE-GUI.png"))
        self.template_instruction = QLabel()
        self.template_instruction.setPixmap(pixmap)

        # List all files in the directory
        directory = resource_path("media/templates")
        files = os.listdir(directory)
        installation_icons = QWidget()
        hIconLayout = QHBoxLayout()

        for file in files:
            # Check if the file is an image (you can add other formats if needed)
            if file.endswith(".png") or file.endswith(".jpg") or file.endswith(".jpeg"):
                # Create the full file path
                filepath = os.path.join(directory, file)

                # Load the image into QPixmap
                pixmap = QPixmap(filepath)

                # Scale pixmap
                pixmap = pixmap.scaled(45, 45)

                # Create a QLabel and set the QPixmap to it
                label = QLabel()
                label.setPixmap(pixmap)

                # Add label to the layout
                hIconLayout.addWidget(label)

        installation_icons.setLayout(hIconLayout)
        v_layout_templates.addWidget(installation_icons)

        self.label_qvm_template_gui = QLabel("Look for i3sec templates in repository column ")
        v_layout_templates.addWidget(self.label_qvm_template_gui)
        v_layout_templates.addWidget(self.template_instruction)

        self.btn_go_to_qvm_template_gui = QPushButton("Go to qvm-template-gui")
        self.btn_go_to_qvm_template_gui.setCheckable(False)
        self.btn_go_to_qvm_template_gui.clicked.connect(self.go_to_qvm_template_gui)
        v_layout_templates.addWidget(self.btn_go_to_qvm_template_gui)
        if is_inited_repo_3isec_tmpl():
            self.show_qvm_template_gui()
        else:
            self.hide_qvm_template_gui()
        return v_layout_templates

    def render_repo_install(self):
        test_repo_install_warning = "The tasks repository is not installed"
        text1 = "The official instruction from UNMAN about how to install the tasks repository"
        text2 = """

                    [3isec-dom0-current]
                    name = 3isec Qubes Dom0 Repository (updates)
                    baseurl = https://qubes.3isec.org/rpm/r$releasever/current/dom0/fc32
                    skip_if_unavailable=False
                    enabled = 1
                    metadata_expire = 6h
                    gpgcheck = 1
                    gpgkey = file:///etc/pki/rpm-gpg/RPM-GPG-KEY-unman

                    Create a file in dom0 with this content at /etc/yum.repos.d/3isec-dom0.repo

                    All packages are signed with my Qubes OS Signing key.
                    You'll need to get this from a keyserver, or two, to make sure all is fine:
                    keyserver.ubuntu.com or pgp.mit.edu

                    You can also check the Qubes users mailing list or look on github.

                    Once you have copies of the key, check the fingerprint:

                    gpg -n --import --import-options import-show unman.pub

                    replacing unman.pub with the path to the key.
                    The output should look similar to this:

                    pub   rsa4096 2016-06-25 [SC]
                          4B1F 400D F256 51B5 3C41  41B3 8B3F 30F9 C8C0 C2EF
                    uid           [ unknown] unman (Qubes OS signing key) 
                    sub   rsa4096 2016-06-27 [S] [expires: 2024-06-30]
                    sub   rsa4096 2016-06-25 [E]

                    In particular, check that the output from your command contains the fingerprint 4B1F 400D F256 51B5 3C41 41B3 8B3F 30F9 C8C0 C2EF

                    When you are happy, copy the key in to dom0:

                    qvm-run -p QUBE_WHERE_YOU_DOWNLOADED_KEY 'cat PATH_TO_KEY' > RPM-GPG-KEY-unman
                    sudo mv RPM-GPG-KEY-unman /etc/pki/rpm-gpg/
                    """

        # Create QLabel instance with some text
        label = QLabel(text1)
        lbl = QLabel(text2)

        lbl1 = QLabel("<b>OR you can set up it automatically (will run subcomands with \"sudo\") </b>")
        lbl1.setAlignment(Qt.AlignCenter)
        scroll2 = QScrollArea()
        scroll2.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        scroll2.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll2.setWidgetResizable(True)
        scroll2.setWidget(lbl)

        # Create QPushButton instances for OK and Cancel
        button_ok = QPushButton("<b>OR you can set up it automatically (will run subcomands with \"sudo\") </b>")

        def accept():
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Question)
            msgBox.setText("This action will run subcommands with \"sudo\".")
            msgBox.setWindowTitle("Warning")
            msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)

            returnValue = msgBox.exec()
            if returnValue == QMessageBox.Ok:
                install_repo_3isec()
                self.taskContainerLayout.setCurrentIndex(2)

        # Connect buttons to the appropriate slots (functions)
        button_ok.clicked.connect(accept)  # built-in QDialog function to accept (OK) the dialog

        # Add the QLabel and QPushButtons to the layout
        installStackLayout = QVBoxLayout()
        # containerLayout.addWidget(self.searchbar)
        installStackLayout.addWidget(label)
        installStackLayout.addWidget(scroll2, 40)
        # installStackLayout.addWidget(lbl1)
        installStackLayout.addWidget(button_ok)
        installStackWidget = QWidget()
        installStackWidget.setLayout(installStackLayout)
        return installStackWidget

    def render_tasks(self):
        # Tab tasks
        self.tasksLayout = QVBoxLayout()  # Tasks container layout.
        self.taskGroup = QButtonGroup()
        self.taskGroup.setExclusive(False)
        spacer = QSpacerItem(1, 1, QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.tasks = QWidget()
        self.tasksLayout.addItem(spacer)
        self.tasks.setLayout(self.tasksLayout)
        self.lbl = QLabel(""" Description
                            """)
        self.lbl.setAlignment(Qt.AlignTop)
        # Scroll Area Properties.
        self.scroll = QScrollArea()
        self.scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll.setWidgetResizable(True)
        self.scroll.setWidget(self.tasks)

        self.scroll2 = QScrollArea()
        self.scroll2.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.scroll2.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll2.setWidgetResizable(True)
        self.scroll2.setWidget(self.lbl)

        self.searchbar = QLineEdit()
        self.btn_install = QPushButton("Install")
        self.btn_install.setCheckable(False)
        self.btn_install.clicked.connect(self.install_tasks)

        self.refresh_on_start_checkbox2 = QCheckBox("Refresh tasks on start")
        self.refresh_on_start_checkbox2.setChecked(self.update_on_start())
        self.refresh_on_start_checkbox2.stateChanged.connect(
            self.checkbox_state_changed)  # Connect the signal to the slot

        taskStackLayout = QVBoxLayout()
        # containerLayout.addWidget(self.searchbar)
        taskStackLayout.addWidget(self.btn_install)
        taskStackLayout.addWidget(self.refresh_on_start_checkbox2)
        taskStackLayout.addWidget(self.scroll, 60)
        taskStackLayout.addWidget(self.scroll2, 40)
        taskStackWidget = QWidget()
        taskStackWidget.setLayout(taskStackLayout)
        return taskStackWidget

    def install_templates(self):
        install_repo_3isec_tmpl()
        self.show_qvm_template_gui()

    def go_to_qvm_template_gui(self):
        subprocess.Popen(["qvm-template-gui"], start_new_session=True)

    def show_qvm_template_gui(self):
        self.btn_template_inst.hide()
        self.label_qvm_template_gui.show()
        self.btn_go_to_qvm_template_gui.show()
        self.template_instruction.show()

    def hide_qvm_template_gui(self):
        self.btn_template_inst.show()
        self.label_qvm_template_gui.hide()
        self.btn_go_to_qvm_template_gui.hide()
        self.template_instruction.hide()

    def refresh_widget(self):
        # Tab tasks
        self.default_refresh_text = """ Update can take time in case of weak connection or if sys-whonix not started\n"""
        self.lbl = QLabel(self.default_refresh_text)
        self.lbl.setAlignment(Qt.AlignTop)
        self.lbl.hide()
        self.refresh_counter = 1

        self.refresh_on_start_checkbox1 = QCheckBox("Refresh tasks on start")
        self.refresh_on_start_checkbox1.setChecked(self.update_on_start())
        self.refresh_on_start_checkbox1.stateChanged.connect(
            self.checkbox_state_changed)  # Connect the signal to the slot

        self.btn_refresh = QPushButton("Pull tasks; can take time if sys-whonix not started")
        self.btn_refresh.setCheckable(False)
        self.btn_refresh.clicked.connect(self.refresh_tasks)

        refreshStackLayout = QVBoxLayout()
        refreshStackLayout.addWidget(self.btn_refresh)
        refreshStackLayout.addWidget(self.lbl)
        refreshStackLayout.addWidget(self.refresh_on_start_checkbox1)
        refreshStackWidget = QWidget()
        refreshStackWidget.setLayout(refreshStackLayout)
        return refreshStackWidget

    def finish_refresh(self, results):
        self.outputs = {}
        self.outputs = results
        if "exception" in self.outputs:
            QtWidgets.QMessageBox.warning(
                self,
                self.tr("EXCEPTION"),
                self.tr(f"Happened exception during tasks refresh {self.outputs['exception']}\n PLEASE TRY AGAIN"))
            self.btn_refresh.show()
            self.lbl.hide()
        else:
            self.widget_names = self.outputs.keys()
            for name in self.widget_names:
                detail = self.outputs[name]['summary']
                item = TaskRowWidget(self, name, detail)
                self.tasksLayout.addWidget(item)
            self.taskContainerLayout.setCurrentIndex(0)
        self.refresh_timer.stop()

    def refresh_tasks(self):
        self.btn_refresh.hide()
        self.lbl.show()
        self.refresh_timer = QTimer()
        self.refresh_timer.setInterval(1000)  # 1000 ms = 1 s
        self.refresh_timer.timeout.connect(self.update_label)
        self.refresh_timer.start()
        self.worker = Worker()
        self.worker.finished.connect(self.finish_refresh)
        self.worker.start()

    def update_label(self):
        self.refresh_counter += 1

        refresh_text = self.default_refresh_text
        refresh_text += f"\nit runs for {self.refresh_counter} sec \n"
        if self.refresh_counter > 8:  # i just choosed 8; no sense
            refresh_text += "\nrefresh taking longer then usual probably it inits sys-whonix\n"

        self.lbl.setText(refresh_text)

    def details_clicked(widget, state):
        sending_widget = widget.sender()
        name = (sending_widget.accessibleName())
        desc = widget.outputs[name]['description']
        w.lbl.setText(desc)

    def install_tasks(widget, state):
        update_cmd = "sudo qubes-dom0-update "
        prefix = "3isec-qubes-"
        checked_buttons = [i for i, button in enumerate(w.taskGroup.buttons()) if button.isChecked()]
        pkgs_to_install = []
        for i in checked_buttons:
            pkgs_to_install.append(prefix + w.taskGroup.buttons()[i].text())
        try:
            if len(pkgs_to_install) == 0:
                QtWidgets.QMessageBox.warning(
                    widget,
                    widget.tr("No selected tasks"),
                    widget.tr("No tasks were selected"))
                return
            install_list = " ".join(pkgs_to_install)
            child = subprocess.Popen(update_cmd + install_list, shell=True)
            output = child.communicate()[0]
        except Exception as e:  # pylint: disable=broad-except
            # output = child.communicate()[0]
            return 1
        return 0

    def update_on_start(self):
        with shelve.open(self.fancy_state_path) as db:
            if 'update_on_start' in db:
                return db['update_on_start']
            return False

    def set_update_on_start(self, value):
        print(value)
        with shelve.open(self.fancy_state_path) as db:
            db['update_on_start'] = bool(value)  # need stronger validation


app = QtWidgets.QApplication(sys.argv)
w = MainWindow()
w.show()
sys.exit(app.exec_())
